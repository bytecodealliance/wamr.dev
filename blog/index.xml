<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://bytecodealliance.github.io/wamr.dev/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 Oct 2022 08:49:55 +0000</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>The wasm-host data transfer: challenges</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-data-transfer-challenges/</link><pubDate>Mon, 24 Apr 2023 16:19:14 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-data-transfer-challenges/</guid><description>Background # When we try to integrate WASM with CHRE(Context Hub Rutime Environment) and LVGL(Light and Versatile Graphics Library), we meet some challenges in data transferring and sharing. The following article will introduce these challenges.
CHRE is the software environment where small native applications, called nanoapps, execute on a low-power processor and interact with the underlying system through the common CHRE API. We try to compile nanoapps into WASM and embed WAMR into CHRE to enable CHRE to run these new nanoapps compiled as WASM.</description></item><item><title>The wasm-host data transfer: basics</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-data-transfer-basics/</link><pubDate>Fri, 21 Apr 2023 13:27:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-data-transfer-basics/</guid><description>Overview # 1. Two worlds # The data transferring occur between two worlds: the native world and the wasm world. The native world refers to the memory space that the host program can legally access, and the wasm world refers to the memory space that the wasm program can legally access.
The native world contians the wasm world, so the host program can access both two worlds, but the wasm program can access the wasm world only.</description></item><item><title>Transferring data from wasm apps to host: Part 2</title><link>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-wasm-apps-to-host-part-2/</link><pubDate>Tue, 11 Apr 2023 11:30:09 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-wasm-apps-to-host-part-2/</guid><description>This article is a continuation of Transferring data from wasm apps to host: Part 2, mainly about the encapsulation of function pointer in different contexts.
4 Structure is used to saved returned data # 4.1 The space of the returned data belongs to the native world # In the wasm context, we may save the returned data in the structure used as the parameter of wasm call native. If the space of the returned data is belongs to the native wolrd, then we have to do some additional work to make the wasm context accessible to this data.</description></item><item><title>Transferring data from wasm apps to host : Part 1</title><link>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-wasm-apps-to-host-part-1/</link><pubDate>Mon, 10 Apr 2023 18:24:33 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-wasm-apps-to-host-part-1/</guid><description>Overview: From Wasm to Native # This section will introduce how to transfer data from the wasm world to the native world.
This topic has a lot of content, so this article will be divided into 2 parts.
The part 1 mainly discusses the structure. The part 2 mainly discussed the function pointer. Unlike the case of &amp;ldquo;Transferring data from host to wasm apps&amp;rdquo;, the native context can access memory from both worlds, so in many cases we can avoid copying memory.</description></item><item><title>Transferring data from host to wasm apps</title><link>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-host-to-wasm-apps/</link><pubDate>Tue, 04 Apr 2023 15:40:31 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/transferring-data-from-host-to-wasm-apps/</guid><description>Overview: From Native to Wasm # This section mainly introduces the situation of transferring data from the native world to the WASM world, which usually occurs in two scenarios:
Parameter transfer in native call WASM When WASM call native, the parameter is used to store the return value It should be noted that the WASM context cannot directly access the memory of the native world, so in most cases, memory copying is still necessary.</description></item><item><title>Architecture for transferring data between host and wasm app</title><link>https://bytecodealliance.github.io/wamr.dev/blog/architecture-for-transferring-data-between-host-and-wasm-app/</link><pubDate>Mon, 03 Apr 2023 21:03:20 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/architecture-for-transferring-data-between-host-and-wasm-app/</guid><description>Architecture for transferring data between Host and WASM app # To facilitate handling various situations of data transmission, we need to design an overall architecture to handle data transmission situations. Of course, you don&amp;rsquo;t necessarily need this architecture, it&amp;rsquo;s just a reference.
This architecture is divided into 5 layers: the native layer, the native wrapper layer, the wasm wrapper layer, and the wasm layer, the mapping layer.
The native layer, the native wrapper layer and the mapping layer are all running in the native context, while the wasm layer and the wasm wrapper layer are both running in the wasm context.</description></item><item><title>Overview of transfering data between Host and WASM app</title><link>https://bytecodealliance.github.io/wamr.dev/blog/overview-of-transfering-data-between-host-and-wasm-app/</link><pubDate>Mon, 03 Apr 2023 19:02:23 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/overview-of-transfering-data-between-host-and-wasm-app/</guid><description>When discussing the method of transferring data between the Host and WASM app, we need to identify three concepts: execution context, memory space and memory layout. This article will introduce these 3 concepts.
1 Execution Context # The execution context refers to whether the currently executing code is WASM or Native. If WASM code is currently running, we call it the WASM context. If Native code is currently running, we call it the Native context.</description></item><item><title>The WAMR memory model</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</link><pubDate>Tue, 21 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</guid><description>The WAMR memory categories # According to the lifecycle and associated functionalities, we put the memory used in WAMR into four categories:
runtime memory: memory used by runtime globally Wasm module memory: memory used for a loaded Wasm module, freed when the module is unloaded Wasm module instance memory: memory used for a Wasm module instance, freed when the instance is destroyed Execution environment memory: memory use for execution of Wasm function from a Wasm module instance.</description></item><item><title>Understand the WAMR stacks</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</link><pubDate>Sat, 18 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</guid><description>The status of stacks # During the WAMR executes a Wasm function, there will be a Wasm stack created and used. For interpreter mode, as the Wasm functions intercall, the Wasm stack frames will grow, while the native stack keeps unchanged.
When the Wasm calls into a imported native function and the native function then call into some Wasm function, the native stack will add a frame, and an empty frame will be inserted into wasm stack to indicate the function is imported from native.</description></item><item><title>Understand the WAMR heaps</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</link><pubDate>Fri, 17 Mar 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</guid><description>Linear memory # The linear memory is a contiguous, mutable array of raw bytes. For most compilers, e.g. wasi-sdk, emsdk, rustc or asc, normally it includes three parts, data area, auxiliary stack area and heap area. The initial and maximum sizes of linear memory can be configured through the compilation parameters:
For wasi-sdk, the initial/max size can be specified with -Wl,&amp;ndash;initial-memory=n1,&amp;ndash;max-memory=n2 For emsdk, the initial/max size can be specified with -s INITIAL_MEMORY=n1 -s MAXIMUM_MEMORY=n2 -s ALLOW_MEMORY_GROWTH=1 or -s TOTAL_MEMORY=n For asc, they can be specified with &amp;ndash;initialMemory and &amp;ndash;maximumMemory flags</description></item></channel></rss>