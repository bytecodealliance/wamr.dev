<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://bytecodealliance.github.io/wamr.dev/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 Oct 2022 08:49:55 +0000</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Understand the WAMR heap</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heap/</link><pubDate>Fri, 17 Mar 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heap/</guid><description>Linear memory # The linear memory is a contiguous, mutable array of raw bytes. For most compilers, e.g. wasi-sdk, emsdk, rustc or asc, normally it includes three parts, data area, auxiliary stack area and heap area.
For wasi-sdk, the initial/max size can be specified with -Wl,&amp;ndash;initial-memory=n1,&amp;ndash;max-memory=n2 For emsdk, the initial/max size can be specified with -s INITIAL_MEMORY=n1 -s MAXIMUM_MEMORY=n2 -s ALLOW_MEMORY_GROWTH=1 or -s TOTAL_MEMORY=n For asc, they can be specified with &amp;ndash;initialMemory and &amp;ndash;maximumMemory flags</description></item><item><title>Introduction to WAMR running modes</title><link>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-running-modes/</link><pubDate>Thu, 19 Jan 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-running-modes/</guid><description>The options of running a Wasm module # Usually, a WebAssembly module can be executed in either interpreter, Just-In-Time (JIT), or Ahead-Of-Time (AOT) compilation mode, and the choice can be based on the preference for execute performance, resource, etc.
WAMR supports all three modes and even more:
AOT: WAMR AOT helps to achieve nearly native speed, very small footprint, and quick startup. Use the wamrc compiler to compile wasm file to the AOT file, and then run it on iwasm vmcore.</description></item><item><title>WAMR Quality validation pipeline</title><link>https://bytecodealliance.github.io/wamr.dev/blog/wamr-quality-validation-pipeline/</link><pubDate>Tue, 17 Jan 2023 14:17:16 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/wamr-quality-validation-pipeline/</guid><description>WAMR has a long pipeline of quality validation, they are basically separated to two parts.
Public validation pipeline Quick validation for most commonly used features Ensure every PR will not break the basic functionality Internal validation pipeline 7 * 24 hour available servers for full feature validation Some special designed methods to cover corner cases Public validation pipeline # Public tests requires: fast and efficient license friendly cover most important features Internal validation pipeline # These tests are maintained internally because they are: time consuming, or never end using incompatible licenses compiled binaries which may not be suitable to commit to repo requiring complex environment setup using commercial software which require paid licenses</description></item><item><title>Debugging wasm with VSCode</title><link>https://bytecodealliance.github.io/wamr.dev/blog/debugging-wasm-with-vscode/</link><pubDate>Wed, 26 Oct 2022 16:28:09 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/debugging-wasm-with-vscode/</guid><description>Debugging with VSCode # VSCode&amp;rsquo;s flexible extension system make it very easy to integrate any debuggers to its UI, we have developed a VSCode extension to provide some simple project management functionality, and of cause, including the debugging feature.
Build the extension from source
Please follow this document to build the extension package.
We are planning to automatically publish this extension by GitHub action, once finished, this step is not necessary.</description></item><item><title>WAMR fast interpreter introduction</title><link>https://bytecodealliance.github.io/wamr.dev/blog/wamr-fast-interpreter-introduction/</link><pubDate>Tue, 18 Oct 2022 19:15:51 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/wamr-fast-interpreter-introduction/</guid><description> A fast WebAssembly Interpreter design in WASM-Micro-Runtime In this paper, we introduced wasm-micro-runtime (abbreviated WAMR) fast-interpreter, in which several optimization methods are applied including fast bytecode dispatching, bytecode fusion, etc. Experiments show that the performance can be improved by ~150% on CoreMark compared with the classic stack-based interpreter. www.intel.com</description></item><item><title>WAMR source debugging basic</title><link>https://bytecodealliance.github.io/wamr.dev/blog/wamr-source-debugging-basic/</link><pubDate>Sat, 15 Oct 2022 14:23:03 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/wamr-source-debugging-basic/</guid><description>Image from https://pspdfkit.com/blog/2020/the-state-of-debugging-in-webassembly/ Table Of Contents Background Setup Debugging with CLI Remote debugging Issue with evaluation feature FAQ Background # Debugging takes a great part in application development, debuggers provide the capability to inspect the internal state of the execution programs, which make it easier to let the program work properly. It is hard to imagine a programming world without debugger.
Luckily, WAMR has supported source debugging feature based on lldb, and now is ready for use.</description></item></channel></rss>