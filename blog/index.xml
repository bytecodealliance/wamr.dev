<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://bytecodealliance.github.io/wamr.dev/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 Oct 2022 08:49:55 +0000</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>WAMR 2024: A Year in Review</title><link>https://bytecodealliance.github.io/wamr.dev/blog/wamr-2024-a-year-in-review/</link><pubDate>Sun, 21 Jan 2024 09:20:00 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/wamr-2024-a-year-in-review/</guid><description>WAMR 2024: A Year in Review # In 2024, the WAMR community saw many thrilling advancements, including the development of new features, increased industrial use, and an improved experience for developers. Passionate developers and industry professionals have come together to enhance and expand WAMR in ways we couldn&amp;rsquo;t have imagined. From exciting new tools to a growing community, there&amp;rsquo;s a lot to be proud of. Let&amp;rsquo;s take a closer look at the key highlights of WAMR 2024, showcasing the community&amp;rsquo;s efforts, new features, and the establishment of the Embedded Special Interest Group (ESIG).</description></item><item><title>The WAMR memory model</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</link><pubDate>Tue, 21 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</guid><description>The WAMR memory categories # According to the lifecycle and associated functionalities, we put the memory used in WAMR into four categories:
runtime memory: memory used by runtime globally Wasm module memory: memory used for a loaded Wasm module, freed when the module is unloaded Wasm module instance memory: memory used for a Wasm module instance, freed when the instance is destroyed Execution environment memory: memory use for execution of Wasm function from a Wasm module instance.</description></item><item><title>Introduction to WAMR WASI threads</title><link>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/</link><pubDate>Mon, 03 Jul 2023 00:15:56 +0000</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/</guid><description>One of the functionalities missing in WebAssembly for a long time was the ability to spawn new threads within the process. Various runtimes made efforts to address this limitation by introducing non-standard APIs for thread creation. WAMR provides a WAMR pthread library that implements a wide range of pthread APIs, (including synchronization primitives, pthread_create() function and many more).
In 2022, the introduction of the WASI threads proposal aimed to establish a standardized API for thread creation in WebAssembly.</description></item><item><title>Moving the embedded world to WebAssembly : Practice in CHRE</title><link>https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/</link><pubDate>Tue, 16 May 2023 15:18:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/</guid><description>I have recently finished my project of moving CHRE NanoApps from native to WebAssembly without changing the application source code. The source code is available in my GitHub repo cher-wasm.
The major challenges are from Wasm-Host data sharing and function callbacks. This blog will introduce the practice in integrating WASM with CHRE(Context Hub Runtime Environment), and how to some challenges. It should be useful for moving other existing project to Wasm based user applications.</description></item><item><title>The Wasm-Host sharing data: challenges</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-challenges/</link><pubDate>Mon, 24 Apr 2023 16:19:14 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-challenges/</guid><description>Background # I have tried to integrate WASM with CHRE (Context Hub Runtime Environment) at my GitHub repo (cher-wasm), and before that I learned the LVGL (Light and Versatile Graphics Library) samples provided by WAMR.
CHRE is the Android sensor hub framework where small native applications, called nanoapps, which are executed on a low-power processor and interact with the underlying system through the common CHRE API. My goal was compiling the nanoapps source code into WASM and run them on the WAMR embedded into CHRE.</description></item><item><title>The Wasm-Host sharing data: basics</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-basics/</link><pubDate>Fri, 21 Apr 2023 13:27:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-basics/</guid><description>Overview # 1. Two worlds # The data transferring occur between two worlds: the native world and the Wasm world. The native world refers to the memory space that the host program can legally access, and the Wasm world refers to the memory space that the Wasm program can legally access.
The native world contains the Wasm world, so the host program can access both two worlds, but the Wasm program can access the Wasm world only.</description></item><item><title>Understand the WAMR stacks</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</link><pubDate>Sat, 18 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</guid><description>The status of stacks # During the WAMR executes a Wasm function, there will be a Wasm stack created and used. For interpreter mode, as the Wasm functions intercall, the Wasm stack frames will grow, while the native stack keeps unchanged.
When the Wasm calls into a imported native function and the native function then call into some Wasm function, the native stack will add a frame, and an empty frame will be inserted into wasm stack to indicate the function is imported from native.</description></item><item><title>Understand the WAMR heaps</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</link><pubDate>Fri, 17 Mar 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</guid><description>Linear memory # The linear memory is a contiguous, mutable array of raw bytes. For most compilers, e.g. wasi-sdk, emsdk, rustc or asc, normally it includes three parts, data area, auxiliary stack area and heap area. The initial and maximum sizes of linear memory can be configured through the compilation parameters:
For wasi-sdk, the initial/max size can be specified with -Wl,&amp;ndash;initial-memory=n1,&amp;ndash;max-memory=n2 For emsdk, the initial/max size can be specified with -s INITIAL_MEMORY=n1 -s MAXIMUM_MEMORY=n2 -s ALLOW_MEMORY_GROWTH=1 or -s TOTAL_MEMORY=n For asc, they can be specified with &amp;ndash;initialMemory and &amp;ndash;maximumMemory flags</description></item><item><title>Introduction to WAMR running modes</title><link>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-running-modes/</link><pubDate>Thu, 19 Jan 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-running-modes/</guid><description>The options of running a Wasm module # Usually, a WebAssembly module can be executed in either interpreter, Just-In-Time (JIT), or Ahead-Of-Time (AOT) compilation mode, and the choice can be based on the preference for execute performance, resource, etc.
WAMR supports all three modes and even more:
AOT: WAMR AOT helps to achieve nearly native speed, very small footprint, and quick startup. Use the wamrc compiler to compile wasm file to the AOT file, and then run it on iwasm vmcore.</description></item><item><title>WAMR Quality validation pipeline</title><link>https://bytecodealliance.github.io/wamr.dev/blog/wamr-quality-validation-pipeline/</link><pubDate>Tue, 17 Jan 2023 14:17:16 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/wamr-quality-validation-pipeline/</guid><description>WAMR has a long pipeline of quality validation, they are basically separated to two parts.
Public validation pipeline Quick validation for most commonly used features Ensure every PR will not break the basic functionality Internal validation pipeline 7 * 24 hour available servers for full feature validation Some special designed methods to cover corner cases Public validation pipeline # Public tests requires: fast and efficient license friendly cover most important features Internal validation pipeline # These tests are maintained internally because they are: time consuming, or never end using incompatible licenses compiled binaries which may not be suitable to commit to repo requiring complex environment setup using commercial software which require paid licenses</description></item></channel></rss>