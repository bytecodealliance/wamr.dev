<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://bytecodealliance.github.io/wamr.dev/main.03c609265730470d28863e7912aeee96be8ac7d2fb40cf19664badb5a6ea988534396d83e833626b22865a61556032e2f37341f7e7c02c8d846922568bcbd833.css integrity="sha512-A8YJJlcwRw0ohj55Eq7ulr6Kx9L7QM8ZZkuttabqmIU0OW2D6DNiayKGWmFVYDLi83NB9+fALI2EaSJWi8vYMw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Introduction to WAMR WASI threads - WAMR</title><meta name=description content="One of the functionalities missing in WebAssembly for a long time was the ability to spawn new threads within the process. Various runtimes made efforts to address this limitation by introducing non-standard APIs for thread creation. WAMR provides a WAMR pthread library that implements a wide range of pthread APIs, (including synchronization primitives, pthread_create() function and many more).
In 2022, the introduction of the WASI threads proposal aimed to establish a standardized API for thread creation in WebAssembly."><link rel=canonical href=https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to WAMR WASI threads"><meta property="og:description" content="One of the functionalities missing in WebAssembly for a long time was the ability to spawn new threads within the process. Various runtimes made efforts to address this limitation by introducing non-standard APIs for thread creation. WAMR provides a WAMR pthread library that implements a wide range of pthread APIs, (including synchronization primitives, pthread_create() function and many more).
In 2022, the introduction of the WASI threads proposal aimed to establish a standardized API for thread creation in WebAssembly."><meta property="og:url" content="https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/"><meta property="og:site_name" content="WAMR"><meta property="article:published_time" content="2023-07-03T00:15:56+00:00"><meta property="article:modified_time" content="2023-07-03T00:15:56+00:00"><meta property="og:image" content="https://bytecodealliance.github.io/wamr.dev/wamr.png"><meta property="og:image:alt" content="WAMR"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Introduction to WAMR WASI threads"><meta name=twitter:description content><meta name=twitter:image content="https://bytecodealliance.github.io/wamr.dev/wamr.png"><meta name=twitter:image:alt content="Introduction to WAMR WASI threads"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://bytecodealliance.github.io/#/schema/organization/1","name":"WAMR","url":"https://bytecodealliance.github.io/","sameAs":["https://github.com/bytecodealliance/wamr.dev"],"logo":{"@type":"ImageObject","@id":"https://bytecodealliance.github.io/#/schema/image/1","url":"https://bytecodealliance.github.io/logo-doks.png","width":512,"height":512,"caption":"WAMR"},"image":{"@id":"https://bytecodealliance.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://bytecodealliance.github.io/#/schema/website/1","url":"https://bytecodealliance.github.io/","name":"WAMR","description":"WebAssembly Micro Runtime (WAMR) is a lightweight standalone WebAssembly (WASM) runtime with small footprint, high performance and highly configurable features for applications cross from embedded, IoT, edge to Trusted Execution Environment (TEE), smart contract, cloud native and so on.","publisher":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/","url":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/","name":"Introduction to WAMR WASI threads","description":"","isPartOf":{"@id":"https://bytecodealliance.github.io/#/schema/website/1"},"about":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"},"datePublished":"2023-07-03T00:15:56CET","dateModified":"2023-07-03T00:15:56CET","breadcrumb":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/"]}]},{"@type":"BreadcrumbList","@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/","url":"https://bytecodealliance.github.io/wamr.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/blog/","url":"https://bytecodealliance.github.io/wamr.dev/blog/","name":"Blog"}},{"@type":"ListItem","position":3,"item":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://bytecodealliance.github.io/#/schema/article/1","headline":"Introduction to WAMR WASI threads","description":"","isPartOf":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/"},"mainEntityOfPage":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/"},"datePublished":"2023-07-03T00:15:56CET","dateModified":"2023-07-03T00:15:56CET","author":{"@id":"https://bytecodealliance.github.io/#/schema/person/2"},"publisher":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"},"image":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://bytecodealliance.github.io/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://bytecodealliance.github.io/wamr.dev/blog/introduction-to-wamr-wasi-threads/#/schema/image/2","url":"https://bytecodealliance.github.io/wamr.dev/wamr.png","contentUrl":"https://bytecodealliance.github.io/wamr.dev/wamr.png","caption":"Introduction to WAMR WASI threads"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://bytecodealliance.github.io/wamr.dev/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://bytecodealliance.github.io/wamr.dev/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://bytecodealliance.github.io/wamr.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://bytecodealliance.github.io/wamr.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://bytecodealliance.github.io/wamr.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://bytecodealliance.github.io/wamr.dev/site.webmanifest></head><body class="blog single"><div class=sticky-top><style>.brand{position:relative;float:left;left:10px;z-index:1;padding:16px 0;text-decoration:none;color:#333}.brand:hover{filter:brightness(60%)}</style><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><div><a href=https://bytecodealliance.org/ class=brand><img src=https://bytecodealliance.github.io/wamr.dev//bytecode-alliance-logo.svg alt="Bytecode Alliance logo" width=164></a></div><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=https://bytecodealliance.github.io/wamr.dev/ aria-label=WAMR>WAMR</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/wamr.dev>WAMR</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/wamr.dev/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/wamr.dev/events/>Events</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/wamr.dev/resources/>Resources</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/wamr.dev/apis/>User APIs</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/bytecodealliance/wasm-micro-runtime><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><article><div class="row justify-content-center"><div class="col-md-12 col-lg-10"><div class=blog-header><h1>Introduction to WAMR WASI threads</h1><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;July 3, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/marcin-kolny/>Marcin Kolny</a>&nbsp;&dash;&nbsp;<strong>7&nbsp;min read</strong></small><p></div></div><div class=col-md-13><div></div></div><div class="col-md-12 col-lg-12"><p>One of the functionalities missing in WebAssembly for a long time was the ability to spawn new threads within the process. Various runtimes made efforts to address this limitation by introducing non-standard APIs for thread creation. WAMR provides a <a href=https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/pthread_library.md><code>WAMR pthread library</code></a> that implements a wide range of pthread APIs, (including synchronization primitives, <code>pthread_create()</code> function and many more).</p><p>In 2022, the introduction of the <a href=https://github.com/WebAssembly/wasi-threads/>WASI threads proposal</a> aimed to establish a standardized API for thread creation in WebAssembly. Subsequently, in 2023, both (<a href=https://github.com/bytecodealliance/wasm-micro-runtime/releases/tag/WAMR-1.2.0>v1.2.0</a>) and <a href=https://wasmtime.dev/>Wasmtime</a> implemented this proposal. This article delves into the implementation details of the WASI threads proposal within WAMR, shedding light on the distinctions between the newly introduced <code>WASI threads</code> and the pre-existing <code>WAMR pthread library</code> implementation.</p><p>See <a href=https://bytecodealliance.org/articles/wasi-threads>the article</a> on the Bytecode Alliance blog for the official WASI threads announcement.</p><h2 id=wasi-threads---overview>WASI threads - overview <a href=#wasi-threads---overview class=anchor aria-hidden=true>#</a></h2><p>WASI threads proposal (as of today) defines a single hostcall that needs to be implemented by the runtime:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int32_t</span> <span class=nf>thread_spawn</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>start_arg</span><span class=p>)</span>
</span></span></code></pre></div><p>The purpose of this function is to start a new thread and return an identifier associated with that particular thread. The <code>start_arg</code> parameter denotes a value passed to the newly created thread (e.g. can be used as a pointer to a complex data structure in memory). The <code>thread_spawn</code> function is responsible for invoking the following entry function in the new thread:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>wasi_thread_start</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>tid</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>start_arg</span><span class=p>)</span>
</span></span></code></pre></div><p>The <code>wasi_thread_start</code> function must be implemented and exported from the WASM module. The value of the <code>start_arg</code> parameter is the same as the one passed to the <code>thread_spawn</code> function.</p><h2 id=posix-threads-implementation>POSIX threads implementation <a href=#posix-threads-implementation class=anchor aria-hidden=true>#</a></h2><p><code>WAMR pthread library</code> exposes POSIX Threads API to WASM code through native API functions. Each supported function within the library is implemented in WAMR native code and essentially serves as a wrapper for POSIX Threads.</p><p>In contrast, the <code>WASI threads</code> proposal differs from <code>WAMR pthread library</code> implementation as it requires the host environment to only expose a single function (<code>thread_spawn</code>), while the complete implementation of the POSIX Threads API must be included in the WebAssembly code. Many of the API functions, such as <code>pthread_join</code> and TSD, have already been implemented in the <a href=https://github.com/WebAssembly/wasi-libc>WASI libc</a> and can be accessed through the WASI SDK starting from <a href=https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-20>version 20</a>.</p><h4 id=synchronization-primitives>Synchronization primitives <a href=#synchronization-primitives class=anchor aria-hidden=true>#</a></h4><p>The WASI threads proposal focuses only on spawning new threads and does not cover synchronization primitives. However, <code>WASI libc</code> already provides methods such as <code>pthread_mutex*</code> or <code>pthread_cond*</code> that are built on top of another proposal (<a href=threads-and-atomics>Threads and atomics</a>). This proposal&rsquo;s implementation is available in WAMR from version <a href=https://github.com/bytecodealliance/wasm-micro-runtime/releases/tag/WAMR-01-18-2022>01-18-2022</a>.</p><h2 id=memory-model>Memory model <a href=#memory-model class=anchor aria-hidden=true>#</a></h2><p>The WASI threads proposal does not provide specific details about the memory model and treats it as an implementation detail. This paragraph highlights the differences between the memory models used in <code>WASI libc</code> and the <code>WAMR pthread</code> library.</p><p>The <code>WAMR pthread library</code> allocates stack memory for each thread from the auxiliary (AUX) stack. The AUX memory is divided into <code>N+1</code> equal regions, where <code>N</code> represents the maximum number of threads that WAMR can spawn. This maximum thread count can be controlled either through the <code>--max-threads=N</code> flag in <code>iwasm</code> or by setting it programmatically using the <code>wasm_cluster_set_max_thread_num()</code> API.</p><p><img class="img-fluid lazyload blur-up" srcset="/wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_pthread.excalidraw_hu54bc1cfcccd06a3785f0acd08f7c09a4_72921_2d13e0b13720ea6ccf33941b6b8cdb1f.webp 480w, /wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_pthread.excalidraw_hu54bc1cfcccd06a3785f0acd08f7c09a4_72921_3d1ff550cfa60b2ca57be3e3652dbecb.webp 720w, /wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_pthread.excalidraw_hu54bc1cfcccd06a3785f0acd08f7c09a4_72921_881x0_resize_q75_h2_box_3.webp 881w" sizes=80vw src=/wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_pthread.excalidraw_hu54bc1cfcccd06a3785f0acd08f7c09a4_72921_881x0_resize_q75_h2_box_3.webp alt="A visual representation of the WAMR pthread library memory model" width=881 height=218></p><p>On the other hand, the <code>WASI libc</code> implementation dynamically allocates stack memory for each thread from the linear memory, utilizing <code>malloc()</code>. It also allocates memory for thread-local storage (TLS) and thread-specific data (TSD). However, it&rsquo;s important to note that TLS is not supported in the <code>WAMR pthread library</code>. The allocated memory is deallocated upon thread exit, making it available for reuse.
<img class="img-fluid lazyload blur-up" srcset="/wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_wasi_libc.excalidraw_hu65a9471235bd9f4e5b02f30c4a5366a5_104966_69eac6f24d39158f8391874721dfb748.webp 480w, /wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_wasi_libc.excalidraw_hu65a9471235bd9f4e5b02f30c4a5366a5_104966_d5e501dc0b8f4312a0080d16a15ef798.webp 720w, /wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_wasi_libc.excalidraw_hu65a9471235bd9f4e5b02f30c4a5366a5_104966_932x0_resize_q75_h2_box_3.webp 932w" sizes=80vw src=/wamr.dev/blog/introduction-to-wamr-wasi-threads/memory_model_wasi_libc.excalidraw_hu65a9471235bd9f4e5b02f30c4a5366a5_104966_932x0_resize_q75_h2_box_3.webp alt="A visual representation of the WASI libc memory model" width=932 height=352></p><p>Dynamic memory allocation offers the advantage of more efficient memory usage compared to the <code>WAMR pthread library</code>&rsquo;s approach. If an application doesn&rsquo;t frequently utilize the maximum number of threads specified by <code>--max-threads</code>, the pre-allocated memory for those threads remains unutilized, occupying unnecessary space. Additionally, dynamic allocation eliminates the need to determine the number of threads at build time since the AUX stack size is determined by the linker flag.</p><h2 id=wamr-implementation-details>WAMR implementation details <a href=#wamr-implementation-details class=anchor aria-hidden=true>#</a></h2><p>Underneath, the <code>WASI threads</code> feature leverages the existing <a href=https://github.com/bytecodealliance/wasm-micro-runtime/tree/main/core/iwasm/libraries/thread-mgr>thread manager</a> utilized by both the <code>WAMR pthread library</code> and the WAMR embedded scenario. The thread manager keeps track of all the threads within a process, allowing them to interact with each other. For example, if one thread encounters an error, the thread manager can share that information with all the other running threads.</p><p>Conceptually, the process of requesting a new thread in a high level can be summarized as follows:</p><ol><li>Create a new instance of the module that requested a new thread</li><li>Create a new execution environment with the newly created module instance and add it to the thread manager&rsquo;s cluster</li><li>Spawn a native thread; in the thread&rsquo;s entry function, call an exported <code>wasi_thread_start</code> symbol from the module.</li><li>When the <code>wasi_thread_start</code> function completes (i.e. the thread is finished), destroy the module instance and execution environment</li></ol><h2 id=example>Example <a href=#example class=anchor aria-hidden=true>#</a></h2><p>As an example, we&rsquo;ll compile and run a single hello world-like program on <code>iwasm</code> (the code comes from the <a href=https://bytecodealliance.org/articles/wasi-threads>WASI threads announcement</a> article):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define NUM_THREADS 10
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread_entry_point</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>ctx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; in thread %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pthread_t</span> <span class=n>threads</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NUM_THREADS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>threads</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>thread_entry_point</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;failed to spawn thread: %s&#34;</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NUM_THREADS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_join</span><span class=p>(</span><span class=n>threads</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=configure-wamr>Configure WAMR <a href=#configure-wamr class=anchor aria-hidden=true>#</a></h4><p>To enable WASI threads support in WAMR, the flag <code>WAMR_BUILD_LIB_WASI_THREADS</code> needs to be set to <code>1</code>. E.g. to build <code>iwasm</code> for linux platform, use:</p><pre tabindex=0><code>cmake -Bbuild -Sproduct-mini/platforms/linux/ -DWAMR_BUILD_LIB_WASI_THREADS=1
</code></pre><p>In addition to that, user can specify a maximum number of running threads:</p><ul><li>for <code>iwasm</code>, use <code>--max-threads</code> CLI argument</li><li>for embedded WAMR, use <code>wasm_runtime_set_max_thread_num</code> to set the max number of threads
If the max value is not specified, default value (currently set to 4) is used.</li></ul><h4 id=compile-wasm-code>Compile WASM code <a href=#compile-wasm-code class=anchor aria-hidden=true>#</a></h4><p>The easiest way to compile WASM application is through <a href=https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-20>WASI SDK v20</a> (threading support is available from version 20).</p><pre tabindex=0><code>/opt/wasi-sdk/bin/clang --target=wasm32-wasi-threads -Wl,--max-memory=1048576 -pthread hello_world.c -o hello_world.wasm
</code></pre><h4 id=run-wasm-code>Run WASM code <a href=#run-wasm-code class=anchor aria-hidden=true>#</a></h4><p>The program can be now run e.g. using <code>iwasm</code>:</p><pre tabindex=0><code>./iwasm --max-threads=4 hello_world.wasm
</code></pre><p>And the output should be similar to:</p><pre tabindex=0><code>Creating thread 0
Thread #262180, counter: 0
Creating thread 1
Thread #327860, counter: 0
Final counter value: 2
</code></pre><h2 id=benchmarking>Benchmarking <a href=#benchmarking class=anchor aria-hidden=true>#</a></h2><p>Just to demonstrate the potential benefits of running multi-threaded applications, we ran <code>iwasm</code> with two different parallelizable WASM programs:</p><ul><li><a href=https://github.com/loganek/wasi-threads-examples/tree/main/merge_sort>sorting</a> - parallel implementation of merge sort</li><li><a href=https://github.com/bytecodealliance/wasm-parallel-gzip>compression</a> - pigz and gzip compiled to WASM</li></ul><table><thead><tr><th>Number of threads</th><th>Compression</th><th>Sorting</th></tr></thead><tbody><tr><td>1</td><td>67s</td><td>11s</td></tr><tr><td>2</td><td>39s</td><td>6s</td></tr></tbody></table><p>As expected, WASM program with two threads is about two times faster than its single-threaded version.</p><h2 id=next-steps>Next steps <a href=#next-steps class=anchor aria-hidden=true>#</a></h2><p>In the past few months, the team spent a massive amount of time validating an implementation by testing various scenarios. That resulted with many bug fixes and significant stability improvements in the latest <a href=https://github.com/bytecodealliance/wasm-micro-runtime/releases/tag/WAMR-1.2.2>WAMR 1.2.2</a> release. Thanks to a team effort, WAMR supports now multi-threading for interpreter (classic, fast), JIT (LLVM, fast) and AOT modes. However, we&rsquo;re not done yet:</p><ul><li>Rust toolchain support - WASI threads are already available to C programs through WASI libc. Using threads in Rust was not straightforward, but there&rsquo;s already <a href=https://github.com/rust-lang/rust/pull/112922>work in progress</a> to implement the <code>std::thread</code> module from Rust standard library for the <code>wasm32-wasi-threads</code> target</li><li>WASI threads API extensions - at the moment WASI threads API consists of a single function; there are currently discussions on whether more functions should be added to the interface (e.g. <a href=https://github.com/WebAssembly/wasi-threads/issues/7>the discussion</a> about <code>pthread_exit</code>-like interface)</li><li>many other bigger and smaller discussions regarding the specification - see <a href=https://github.com/WebAssembly/wasi-threads/issues>the Github page</a> for all the open threads</li></ul><h2 id=contributors>Contributors <a href=#contributors class=anchor aria-hidden=true>#</a></h2><p>The development of WASI threads in WAMR was a team effort involving various folks who deserve a big thanks:</p><ul><li>Alexandru Ene, Andrew Brown and Takashi Yamamoto for shaping the WASI threads proposal.</li><li>Sam Clegg and Dan Gohman for their awesome work on the toolchain to support threading.</li><li>Enrico Loparco, Georgii Rylov, Hritik Gupta and Wenyong Huang for making the proposal a reality in WAMR.</li></ul><div class=card><div class=card-header>Interested in WAMR?</div><div class=card-body><div class=row><a style=margin-top:10px href=https://bytecodealliance.zulipchat.com/#narrow/stream/290350-wamr><img src=https://img.shields.io/badge/zulip-join_chat-brightgreen.svg></a>
<a style=margin-top:10px href=https://github.com/bytecodealliance/wasm-micro-runtime><img alt="GitHub Repo stars" src="https://img.shields.io/github/stars/bytecodealliance/wasm-micro-runtime?label=WAMR%C2%B7Stars&style=social"></a>
<a style=margin-top:10px href=https://github.com/bytecodealliance/wasm-micro-runtime/fork><img alt="GitHub forks" src="https://img.shields.io/github/forks/bytecodealliance/wasm-micro-runtime?label=WAMR%C2%B7Forks&style=social"></a></div></div></div></div></div></article><div class=related-posts><div class="row justify-content-center"><div class=col><h2 class=section-title>Related posts</h2></div></div><div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-lg-5"><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="Moving the embedded world to WebAssembly : Practice in CHRE"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/>Moving the embedded world to WebAssembly : Practice in CHRE</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;May 16, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>10&nbsp;min read</strong></small><p></article></div></div></div><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="The Wasm-Host sharing data: challenges"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/the-wasm-host-sharing-data-challenges/>The Wasm-Host sharing data: challenges</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;April 24, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>4&nbsp;min read</strong></small><p></article></div></div></div><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="The Wasm-Host sharing data: basics"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/the-wasm-host-sharing-data-basics/>The Wasm-Host sharing data: basics</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;April 21, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>5&nbsp;min read</strong></small><p></article></div></div></div></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=/wamr.dev/js/bootstrap.min.650aeec64c81d69d4c0850fc73c93da3f0330cec0a27772feed7f90f60baa5f47f1c45687d71914bdafd1c4e860d40f6dc08ede27a2f08431ff929c9a2d24621.js integrity="sha512-ZQruxkyB1p1MCFD8c8k9o/AzDOwKJ3cv7tf5D2C6pfR/HEVofXGRS9r9HE6GDUD23Ajt4novCEMf+SnJotJGIQ==" crossorigin=anonymous defer></script>
<script src=/wamr.dev/js/highlight.min.6efdec8375dd620e0a357860aafeb5c97c7b51f33c9c594d57fa7f76cf22d2a6e0e39f8127dfed74d737512bfdb23f641827578b3fe09da15442a003c878a033.js integrity="sha512-bv3sg3XdYg4KNXhgqv61yXx7UfM8nFlNV/p/ds8i0qbg45+BJ9/tdNc3USv9sj9kGCdXiz/gnaFUQqADyHigMw==" crossorigin=anonymous defer></script>
<script src=/wamr.dev/main.min.cb2e2ebbf2e4002f3117addc33582923b2b3ae5265c22944cd117ebec7abe61c170417c4506d7a0f8f0fc9053dfdf441421d53601ac467042ff3d06ec0ba07fa.js integrity="sha512-yy4uu/LkAC8xF63cM1gpI7KzrlJlwilEzRF+vser5hwXBBfEUG16D48PyQU9/fRBQh1TYBrEZwQv89BuwLoH+g==" crossorigin=anonymous defer></script>
<script src=https://bytecodealliance.github.io/wamr.dev/index.min.4ae26272486ea46c5bb0bed7a0b434a91b05e8182cfb839a405dd4e647b05ce5d76d401a5103d822d3b1589fc56335cd372b712d97085b8d89aebf244b1b5501.js integrity="sha512-SuJickhupGxbsL7XoLQ0qRsF6Bgs+4OaQF3U5kewXOXXbUAaUQPYItOxWJ/FYzXNNytxLZcIW42Jrr8kSxtVAQ==" crossorigin=anonymous defer></script></body></html>