<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://bytecodealliance.github.io/wamr.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=https://bytecodealliance.github.io/wamr.dev/main.03c609265730470d28863e7912aeee96be8ac7d2fb40cf19664badb5a6ea988534396d83e833626b22865a61556032e2f37341f7e7c02c8d846922568bcbd833.css integrity="sha512-A8YJJlcwRw0ohj55Eq7ulr6Kx9L7QM8ZZkuttabqmIU0OW2D6DNiayKGWmFVYDLi83NB9+fALI2EaSJWi8vYMw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Moving the embedded world to WebAssembly : Practice in CHRE - WAMR</title><meta name=description content="I have recently finished my project of moving CHRE NanoApps from native to WebAssembly without changing the application source code. The source code is available in my GitHub repo cher-wasm.
The major challenges are from Wasm-Host data sharing and function callbacks. This blog will introduce the practice in integrating WASM with CHRE(Context Hub Runtime Environment), and how to some challenges. It should be useful for moving other existing project to Wasm based user applications."><link rel=canonical href=https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Moving the embedded world to WebAssembly : Practice in CHRE"><meta property="og:description" content="I have recently finished my project of moving CHRE NanoApps from native to WebAssembly without changing the application source code. The source code is available in my GitHub repo cher-wasm.
The major challenges are from Wasm-Host data sharing and function callbacks. This blog will introduce the practice in integrating WASM with CHRE(Context Hub Runtime Environment), and how to some challenges. It should be useful for moving other existing project to Wasm based user applications."><meta property="og:url" content="https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/"><meta property="og:site_name" content="WAMR"><meta property="article:published_time" content="2023-05-16T15:18:38+08:00"><meta property="article:modified_time" content="2023-05-16T15:18:38+08:00"><meta property="og:image" content="https://bytecodealliance.github.io/wamr.dev/wamr.png"><meta property="og:image:alt" content="WAMR"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Moving the embedded world to WebAssembly : Practice in CHRE"><meta name=twitter:description content><meta name=twitter:image content="https://bytecodealliance.github.io/wamr.dev/wamr.png"><meta name=twitter:image:alt content="Moving the embedded world to WebAssembly : Practice in CHRE"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://bytecodealliance.github.io/#/schema/organization/1","name":"WAMR","url":"https://bytecodealliance.github.io/","sameAs":["https://github.com/bytecodealliance/wamr.dev"],"logo":{"@type":"ImageObject","@id":"https://bytecodealliance.github.io/#/schema/image/1","url":"https://bytecodealliance.github.io/logo-doks.png","width":512,"height":512,"caption":"WAMR"},"image":{"@id":"https://bytecodealliance.github.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://bytecodealliance.github.io/#/schema/website/1","url":"https://bytecodealliance.github.io/","name":"WAMR","description":"WebAssembly Micro Runtime (WAMR) is a lightweight standalone WebAssembly (WASM) runtime with small footprint, high performance and highly configurable features for applications cross from embedded, IoT, edge to Trusted Execution Environment (TEE), smart contract, cloud native and so on.","publisher":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/","url":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/","name":"Moving the embedded world to WebAssembly : Practice in CHRE","description":"","isPartOf":{"@id":"https://bytecodealliance.github.io/#/schema/website/1"},"about":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"},"datePublished":"2023-05-16T15:18:38CET","dateModified":"2023-05-16T15:18:38CET","breadcrumb":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/"]}]},{"@type":"BreadcrumbList","@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/","url":"https://bytecodealliance.github.io/wamr.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://bytecodealliance.github.io/wamr.dev/blog/","url":"https://bytecodealliance.github.io/wamr.dev/blog/","name":"Blog"}},{"@type":"ListItem","position":3,"item":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://bytecodealliance.github.io/#/schema/article/1","headline":"Moving the embedded world to WebAssembly : Practice in CHRE","description":"","isPartOf":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/"},"mainEntityOfPage":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/"},"datePublished":"2023-05-16T15:18:38CET","dateModified":"2023-05-16T15:18:38CET","author":{"@id":"https://bytecodealliance.github.io/#/schema/person/2"},"publisher":{"@id":"https://bytecodealliance.github.io/#/schema/organization/1"},"image":{"@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://bytecodealliance.github.io/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/#/schema/image/2","url":"https://bytecodealliance.github.io/wamr.dev/wamr.png","contentUrl":"https://bytecodealliance.github.io/wamr.dev/wamr.png","caption":"Moving the embedded world to WebAssembly : Practice in CHRE"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=https://bytecodealliance.github.io/wamr.dev/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://bytecodealliance.github.io/wamr.dev/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=https://bytecodealliance.github.io/wamr.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://bytecodealliance.github.io/wamr.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://bytecodealliance.github.io/wamr.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://bytecodealliance.github.io/wamr.dev/site.webmanifest></head><body class="blog single"><div class=sticky-top><style>.brand{position:relative;float:left;left:10px;z-index:1;padding:16px 0;text-decoration:none;color:#333}.brand:hover{filter:brightness(60%)}</style><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><div><a href=https://bytecodealliance.org/ class=brand><img src=https://bytecodealliance.github.io/wamr.dev//bytecode-alliance-logo.svg alt="Bytecode Alliance logo" width=164></a></div><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=https://bytecodealliance.github.io/wamr.dev/ aria-label=WAMR>WAMR</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/wamr.dev>WAMR</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/wamr.dev/blog/>Blog</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/wamr.dev/events/>Events</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/wamr.dev/resources/>Resources</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/bytecodealliance/wasm-micro-runtime><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><article><div class="row justify-content-center"><div class="col-md-12 col-lg-10"><div class=blog-header><h1>Moving the embedded world to WebAssembly : Practice in CHRE</h1><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;May 16, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>10&nbsp;min read</strong></small><p></div></div><div class=col-md-13><div></div></div><div class="col-md-12 col-lg-12"><p>I have recently finished my project of moving CHRE NanoApps from native to WebAssembly without changing the application source code. The source code is available in my GitHub repo <a href=https://github.com/FromLiQg/chre-wasm/tree/wasm>cher-wasm</a>.</p><p>The major challenges are from Wasm-Host data sharing and function callbacks. This blog will introduce the practice in integrating WASM with CHRE(Context Hub Runtime Environment), and how to some challenges. It should be useful for moving other existing project to Wasm based user applications.</p><h3 id=1-the-overview-of-chre-wasm>1. The overview of CHRE-WASM <a href=#1-the-overview-of-chre-wasm class=anchor aria-hidden=true>#</a></h3><p><code>CHRE</code> is the Android sensor framework where small native applications, called <code>nanoapp</code>, execute on a low-power processor and interact with the underlying system through the common <code>CHRE API</code>. And CHRE is a event-driven model system, maintaining an event queue and distribute events to nanoapps. We compile nanoapps into WASM and embed WAMR into CHRE to enable CHRE to run these new WASM nanoapps.</p><p>The CHRE framework interacts with a given nanoapp through one of the three nanoapp entry points (<code>nanoappStart()</code>, <code>nanoappHandleEvent()</code>, and <code>nanoappEnd()</code>) or through a callback provided in a prior CHRE API call, and nanoapps interact with the CHRE framework and the underlying system through the CHRE API.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Nanoapp APIs
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Method invoked by the CHRE when loading the nanoapp.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Every CHRE method is legal to call from this method.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>nanoappStart</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Method invoked by the CHRE when there is an event for this nanoapp.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Every CHRE method is legal to call from this method.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param eventData  The associated data, if any, for this specific type of
</span></span></span><span class=line><span class=cl><span class=cm> *     event.  From the nanoapp&#39;s perspective, this eventData&#39;s lifetime ends
</span></span></span><span class=line><span class=cl><span class=cm> *     when this method returns, and thus any data the nanoapp wishes to
</span></span></span><span class=line><span class=cl><span class=cm> *     retain must be copied.  Note that interpretation of event data is
</span></span></span><span class=line><span class=cl><span class=cm> *     given by the event type.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>nanoappHandleEvent</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>senderInstanceId</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>eventType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>eventData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Method invoked by the CHRE when unloading the nanoapp.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>nanoappEnd</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p><img class="img-fluid lazyload blur-up" src=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/images/chre.svg alt="CHRE System"></p><p>When calling the CHRE API on Nanoapp, <code>wasm call native</code> will occur.
When CHRE calls APIs of wasm nanoapp, <code>native call wasm</code> will occur.
In these two processes, it involves both data transfer and sharing, as well as callback functions. We mainly conduct requirement analysis around these two processes.</p><p>We need to insert some intermediate layers, the wasm wrapper layer and native wrappe layer, between CHRE and wasm nanoapp to assist in data sharing and the use of callback functions.</p><p><img class="img-fluid lazyload blur-up" src=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/images/chre_wasm_architecture.svg alt="CHRE-WASM architecture"></p><h3 id=2-challenges-and-solutions>2. Challenges and solutions <a href=#2-challenges-and-solutions class=anchor aria-hidden=true>#</a></h3><p>In this section, we will talk about the challenges we have encountered and the solutions we have used.</p><h4 id=21-delivering-and-receving-event-tofrom-wasm-nanoapp>2.1 Delivering and receving event to/from wasm nanoapp <a href=#21-delivering-and-receving-event-tofrom-wasm-nanoapp class=anchor aria-hidden=true>#</a></h4><h5 id=211-delivering-event>2.1.1 Delivering event <a href=#211-delivering-event class=anchor aria-hidden=true>#</a></h5><p>When CHRE calls nanoapp&rsquo;s API <code>nanoappHandleEvent</code>, event data will be passed to the nanoapp. As the wasm nanoapp cannot directly access data outside of linear memory, and the nanoapp is allowed to directly access the field of the event structure, and we are unable to change the design of the original API, we have to copy the event data to the linear memory, and pass it to the wasm nanoapp.</p><p>If the original design of CHRE was that fields of the event structure must be accessed through APIs, then we could easily pass a <code>handle</code> representing event structure to wasm nanoapp, which will call native API to obtain fields of event structure.</p><h5 id=212-receving-event>2.1.2 Receving event <a href=#212-receving-event class=anchor aria-hidden=true>#</a></h5><p>CHRE will run multiple nanoapps, and may send the same event data to multiple nanoapps. Nanoapps can also send events to other nanoapps.</p><p>The events sent by wasm nanoapp are stored in its linear memory, but one wasm nanoapp cannot directly read the linear memory of other wasm nanoapps. Therefore, we copy the event to the linear memory of wasm nanoapp as event receiver.</p><p>Considering that CHRE may run both native and wasm nanoapps, we first copy the sent event data into <code>the native layer</code>, and it will be pushed into the event queue.</p><p>When an event is queued, if it is passed to the native nanoapp, the native nanoapp can directly access the event data; If it is passed to wasm nanoapp, it needs to be copied to its linear memory.</p><p><img class="img-fluid lazyload blur-up" src=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/images/copy_event.svg alt="CHRE:copy event"></p><h4 id=22-returned-data-used-in-wasm-nanoapp-is-stored-in-native-world>2.2 Returned data used in wasm nanoapp is stored in native world <a href=#22-returned-data-used-in-wasm-nanoapp-is-stored-in-native-world class=anchor aria-hidden=true>#</a></h4><p>The event data received by wasm nanoapp or the return value obtained from the CHRE API contains data stored in the CHRE (host), such as a name (<code>const char *</code>). At this time, wasm nanoapp cannot directly access this part of the data.</p><p>Our approach to this is to create a mapping layer.</p><p>Here is an example, we can see that there is member <code>const char *name</code> in structure. We firstly copy this C-style string <code>name</code> from native to
wasm, then we map the origin string to the new string, and pass the new string to wasm nanoapp.</p><p>In similar situations, we will first check whether the string has been mapped.</p><p>It should be noted that the <code>const char *name</code> in the CHRE host will not be freed, so the copied new string does not need to be freed either.
Otherwise, this will be a relatively troublesome matter: we need to consider how to free the copied string.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * This structure will be passed to wasm nanoapp
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>chreAudioSource</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * Example: &#34;Camcorder Microphone&#34;
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// ignore more fields
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p><img class="img-fluid lazyload blur-up" src=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/images/mapping_strings.svg alt="mapping string"></p><p>Here is the code for this example. We define some functions for mapping, which operate on a globally unique mapping structure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// functions for mapping
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Get the offset mapping to nativeData in WASM Module instance
</span></span></span><span class=line><span class=cl><span class=cm> * @param WASMModuleInst the WASM module instance to find a offset
</span></span></span><span class=line><span class=cl><span class=cm> * @param nativeData the native data to be mapped to the offset
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>getOffset</span><span class=p>(</span><span class=n>wasm_module_inst_t</span> <span class=n>WASMModuleInst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>nativeData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * map the native data to the offset belonging to the WASM Module instance
</span></span></span><span class=line><span class=cl><span class=cm> * @param WASMModuleInst the WASM module instance to find a offset
</span></span></span><span class=line><span class=cl><span class=cm> * @param nativeData the native data to be mapped to the offset
</span></span></span><span class=line><span class=cl><span class=cm> * @param dataOffset the wasm offset of the copied data
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>setNativeData</span><span class=p>(</span><span class=n>wasm_module_inst_t</span> <span class=n>WASMModuleInst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>nativeData</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>dataOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the original CHRE API
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>chreAudioGetSource</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>handle</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=k>struct</span> <span class=nc>chreAudioSource</span> <span class=o>*</span><span class=n>audioSource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the CHRE API wrapper, wasm app will call this api
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>chreAudioGetSourceWrapper</span><span class=p>(</span><span class=n>wasm_exec_env_t</span> <span class=n>exec_env</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>handle</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                               <span class=k>struct</span> <span class=nc>chreAudioSource</span> <span class=o>*</span><span class=n>audioSource</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>nameOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>nameLength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>wasm_module_inst_t</span> <span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Call the CHRE Api
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>success</span> <span class=o>=</span> <span class=p>(</span><span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=n>wasm_runtime_get_module_inst</span><span class=p>(</span><span class=n>exec_env</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=o>&amp;&amp;</span> <span class=n>chreAudioGetSource</span><span class=p>(</span><span class=n>handle</span><span class=p>,</span> <span class=n>audioSource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>success</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// try to find a existed mapping name
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>!=</span> <span class=p>(</span><span class=n>nameOffset</span> <span class=o>=</span> <span class=n>getOffset</span><span class=p>(</span><span class=n>WasmModuleInst</span><span class=p>,</span> <span class=n>audioSource</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>audioSource</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>nameOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nameLength</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>audioSource</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>nameOffset</span> <span class=o>=</span> <span class=n>wasm_runtime_module_malloc</span><span class=p>(</span><span class=n>WasmModuleInst</span><span class=p>,</span> <span class=n>nameLength</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> \
</span></span><span class=line><span class=cl>                                                    <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>**&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>success</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nameOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>success</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>memcpy</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>audioSource</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>nameLength</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>audioSource</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>nameOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=c1>// map this native data to the WASM offset
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>setNativeData</span><span class=p>(</span><span class=n>WasmModuleInst</span><span class=p>,</span> <span class=n>audioSource</span><span class=p>,</span> <span class=n>nameOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>success</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=23-host-unkonwn-structure>2.3 Host Unkonwn structure <a href=#23-host-unkonwn-structure class=anchor aria-hidden=true>#</a></h4><p>When nanoapps send events to other nanoapps, <code>user-defined</code> event structures can be used. Only two nanoapps need to know these structure definitions, without letting CHRE know these.</p><p>However, when CHRE copies event structures from the linear memory of wasm nanoapp, it is necessary to know their structure definition, which needs to be done during the compilationof CHRE.</p><p>Due to the fact that nanoapps can be dynamically loaded and use variable structures, it is impossible to know all event types at compile time.
So we provide another communication method for user-defined structures of nanoapp: serialization.</p><p>We defined a structure for passing serialized messages. When passing events, we serialize the event data and place it in the structure, and pass it out. There are no restrictions on the specific serialization methods used. As long as the serialization/deserialization methods used in both nanoapps are consistent.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//structure for serialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>serialization_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Message length
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Serialization type
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Serialized messages have been stored in here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>message</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Ignore some fields
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h4 id=24-callback-function>2.4 callback function <a href=#24-callback-function class=anchor aria-hidden=true>#</a></h4><p>When nanoapp sends events or messages, it also pass a callback function pointer to CHRE.
This callback function pointer is a wasm function pointer, which is a function table index in native world but needs to be called in native.
We cannot directly pass the wasm function pointer to CHRE, and we cannot change the original design of CHRE.</p><p>Therefore, we must use an intermediate function pointer instead of this wasm function pointer and pass it to CHRE.
When CHRE calls back this intermediate function, the intermediate function then calls the wasm function that actually needs to be called.</p><p>In the image below, we see step 8 from step 1.
Steps 1 to 5 describe the process of sending events through wasm nanoapp.
Steps 6 to 9 describe the process of CHRE calling the callback function.</p><p>After the wasm nanoapp sends an event and a callback function to the CHRE API wrapper, the CHRE API will copy a new native event, map this native event to wasm callback function and other related data, and then pass this native event and the intermediate function to the real CHRE API.</p><p>At an appropriate time, CHRE will call this intermediate function and pass the native event to it. At this point, the intermediate function will find the wasm function that should be called and call this wasm function.</p><p><img class="img-fluid lazyload blur-up" src=/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/images/wasm_function_for_callback.svg alt="wasm callback function"></p><p>Here is a code example that is related to the image above.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Callback which frees data associated with an event.
</span></span></span><span class=line><span class=cl><span class=cm> * When this callback is invoked, &#39;eventData&#39; is no longer needed
</span></span></span><span class=line><span class=cl><span class=cm> * and can be released.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param eventType  The &#39;eventType&#39; argument from chreSendEvent().
</span></span></span><span class=line><span class=cl><span class=cm> * @param eventData  The &#39;eventData&#39; argument from chreSendEvent().
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @see chreSendEvent
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=n>chreEventCompleteFunction</span><span class=p>)(</span><span class=kt>uint16_t</span> <span class=n>eventType</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>eventData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Enqueue an event to be sent to another nanoapp.
</span></span></span><span class=line><span class=cl><span class=cm> * @param eventData  A pointer value that will be understood by the receiving
</span></span></span><span class=line><span class=cl><span class=cm> *     app. Note that the caller no longer owns this memory after the call.
</span></span></span><span class=line><span class=cl><span class=cm> * @param freeCallback  A pointer to a callback function.  After the lifetime
</span></span></span><span class=line><span class=cl><span class=cm> *     of &#39;eventData&#39; is over (either through successful delivery or the event
</span></span></span><span class=line><span class=cl><span class=cm> *     being dropped), this callback will be invoked.  This argument is allowed
</span></span></span><span class=line><span class=cl><span class=cm> *     to be NULL, in which case no callback will be invoked.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @see chreEventDataFreeFunction
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>chreSendEvent</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>eventType</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>eventData</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>chreEventCompleteFunction</span> <span class=o>*</span><span class=n>freeCallback</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>uint32_t</span> <span class=n>targetInstanceId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Fucntions for converting a native event to a wasm event, converting a wasm
</span></span></span><span class=line><span class=cl><span class=cm> * event to a native event, freeing a wasm event and freeing a native event.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>convertFunctions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>eventType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=p>(</span><span class=o>*</span><span class=n>native2Wasm</span><span class=p>)(</span><span class=n>wasm_module_inst_t</span> <span class=p>,</span>  <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>wasm2Native</span><span class=p>)(</span><span class=n>wasm_module_inst_t</span> <span class=p>,</span> <span class=kt>uint32_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>wasmRelease</span><span class=p>)(</span><span class=n>wasm_module_inst_t</span><span class=p>,</span> <span class=kt>uint32_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>nativeRelease</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>convertFunctions</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>mapInternalEventData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>wasm_exec_env_t</span> <span class=n>execEnv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>convertFunctions</span> <span class=o>*</span><span class=n>functions</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>originFuncOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>originDataOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>mapInternalEventData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * mapping void* (native event) to mapInternalEventData
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>mapInternalEventData</span><span class=o>&gt;</span> <span class=n>eventDataMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * The intermediate function for registering callback function in ChreSendEvent
</span></span></span><span class=line><span class=cl><span class=cm> * @see chreSendEvent
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>freeFunc</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=n>eventType</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>eventData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Try to find the original wasm function, the wasm module execution environment,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and the wasm event data.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>wasm_module_inst_t</span> <span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// We try to find a existing wasm function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>item</span> <span class=o>=</span> <span class=n>eventDataMap</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>eventData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>item</span> <span class=o>==</span> <span class=n>eventDataMap</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// set the event type and the wasm event as parameters
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>eventType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>originDataOffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=n>wasm_runtime_get_module_inst</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>execEnv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// call the original wasm function, pass the event type and the wasm event
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>originFuncOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>wasm_runtime_call_indirect</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>execEnv</span><span class=p>,</span>  <span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>originFuncOffset</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// free the copied native event
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>item</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>.</span><span class=n>functions</span><span class=o>-&gt;</span><span class=n>nativeRelease</span><span class=p>(</span><span class=n>eventData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// erase the mapping we used
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>eventDataMap</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * The wasm nanoapp will call this function when calling chreSendEvent
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>chreSendEventWrapper</span><span class=p>(</span><span class=n>wasm_exec_env_t</span> <span class=n>exec_env</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=n>eventType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>uint32_t</span> <span class=n>eventDataForWASM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>uint32_t</span> <span class=n>funcOffset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>uint32_t</span> <span class=n>targetInstanceId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>eventData</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>wasm_module_inst_t</span> <span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>WasmModuleInst</span> <span class=o>=</span> <span class=n>wasm_runtime_get_module_inst</span><span class=p>(</span><span class=n>exec_env</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//get function pointers for converting event between native and wasm
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=n>convertFunctions</span> <span class=o>*</span><span class=n>funcs</span> <span class=o>=</span> <span class=n>getConvertFunctions</span><span class=p>(</span><span class=n>eventType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//get a new copied native event ,and all of the wasm event is copied here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>eventDataForWASM</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>eventData</span> <span class=o>=</span> <span class=n>funcs</span><span class=o>-&gt;</span><span class=n>wasm2Native</span><span class=p>(</span><span class=n>WasmModuleInst</span><span class=p>,</span> <span class=n>eventDataForWASM</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// mapping &#34;the copied native event&#34; to {execution environment, converting functions,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the original wasm function, the original wasm event}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>eventDataMap</span><span class=p>[</span><span class=n>eventData</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exec_env</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>funcs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>funcOffset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>eventDataForWASM</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// call the real CHRE API, but use the intermediate function &#34;freeFunc&#34; for callback
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>chreSendEvent</span><span class=p>(</span><span class=n>eventType</span><span class=p>,</span> <span class=n>eventData</span><span class=p>,</span> <span class=n>freeFunc</span><span class=p>,</span> <span class=n>targetInstanceId</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=card><div class=card-header>Interested in WAMR?</div><div class=card-body><div class=row><a style=margin-top:10px href=https://bytecodealliance.zulipchat.com/#narrow/stream/290350-wamr><img src=https://img.shields.io/badge/zulip-join_chat-brightgreen.svg></a>
<a style=margin-top:10px href=https://github.com/bytecodealliance/wasm-micro-runtime><img alt="GitHub Repo stars" src="https://img.shields.io/github/stars/bytecodealliance/wasm-micro-runtime?label=WAMR%C2%B7Stars&style=social"></a>
<a style=margin-top:10px href=https://github.com/bytecodealliance/wasm-micro-runtime/fork><img alt="GitHub forks" src="https://img.shields.io/github/forks/bytecodealliance/wasm-micro-runtime?label=WAMR%C2%B7Forks&style=social"></a></div></div></div></div></div></article><div class=related-posts><div class="row justify-content-center"><div class=col><h2 class=section-title>Related posts</h2></div></div><div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-lg-5"><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="Introduction to WAMR WASI threads"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/introduction-to-wamr-wasi-threads/>Introduction to WAMR WASI threads</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;July 3, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/marcin-kolny/>Marcin Kolny</a>&nbsp;&dash;&nbsp;<strong>7&nbsp;min read</strong></small><p></article></div></div></div><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="The Wasm-Host sharing data: challenges"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/the-wasm-host-sharing-data-challenges/>The Wasm-Host sharing data: challenges</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;April 24, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>4&nbsp;min read</strong></small><p></article></div></div></div><div class=col><div class=card><img class="card-img-top img-fluid lazyload blur-up" src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_6d8a2b6aa74b933b123f4287214ddce8.webp data-src=https://bytecodealliance.github.io/wamr.dev/images/webassembly-pic_hufbeecd7296df170cb8eea885384f41c3_20814_1270x620_resize_q75_h2_box_3.webp width=1270 height=620 alt="The Wasm-Host sharing data: basics"><div class=card-body><article><h2 class=h3><a class="stretched-link text-body" href=/wamr.dev/blog/the-wasm-host-sharing-data-basics/>The Wasm-Host sharing data: basics</a></h2><p></p><p><small>Posted&nbsp;in&nbsp;<a class="stretched-link position-relative link-muted" href=https://bytecodealliance.github.io/wamr.dev/categories/introduction/>introduction</a>&nbsp;on&nbsp;April 21, 2023 by <a class="stretched-link position-relative" href=https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/>Li Jiongqiang</a>&nbsp;&dash;&nbsp;<strong>5&nbsp;min read</strong></small><p></article></div></div></div></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a class=text-muted href=https://gohugo.io/>Hugo</a>, and <a class=text-muted href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=/wamr.dev/js/bootstrap.min.650aeec64c81d69d4c0850fc73c93da3f0330cec0a27772feed7f90f60baa5f47f1c45687d71914bdafd1c4e860d40f6dc08ede27a2f08431ff929c9a2d24621.js integrity="sha512-ZQruxkyB1p1MCFD8c8k9o/AzDOwKJ3cv7tf5D2C6pfR/HEVofXGRS9r9HE6GDUD23Ajt4novCEMf+SnJotJGIQ==" crossorigin=anonymous defer></script>
<script src=/wamr.dev/js/highlight.min.6efdec8375dd620e0a357860aafeb5c97c7b51f33c9c594d57fa7f76cf22d2a6e0e39f8127dfed74d737512bfdb23f641827578b3fe09da15442a003c878a033.js integrity="sha512-bv3sg3XdYg4KNXhgqv61yXx7UfM8nFlNV/p/ds8i0qbg45+BJ9/tdNc3USv9sj9kGCdXiz/gnaFUQqADyHigMw==" crossorigin=anonymous defer></script>
<script src=/wamr.dev/main.min.cb2e2ebbf2e4002f3117addc33582923b2b3ae5265c22944cd117ebec7abe61c170417c4506d7a0f8f0fc9053dfdf441421d53601ac467042ff3d06ec0ba07fa.js integrity="sha512-yy4uu/LkAC8xF63cM1gpI7KzrlJlwilEzRF+vser5hwXBBfEUG16D48PyQU9/fRBQh1TYBrEZwQv89BuwLoH+g==" crossorigin=anonymous defer></script>
<script src=https://bytecodealliance.github.io/wamr.dev/index.min.4ae26272486ea46c5bb0bed7a0b434a91b05e8182cfb839a405dd4e647b05ce5d76d401a5103d822d3b1589fc56335cd372b712d97085b8d89aebf244b1b5501.js integrity="sha512-SuJickhupGxbsL7XoLQ0qRsF6Bgs+4OaQF3U5kewXOXXbUAaUQPYItOxWJ/FYzXNNytxLZcIW42Jrr8kSxtVAQ==" crossorigin=anonymous defer></script></body></html>