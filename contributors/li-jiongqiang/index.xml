<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Li Jiongqiang on</title><link>https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/</link><description>Recent content in Li Jiongqiang on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 16 May 2023 15:18:38 +0800</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/index.xml" rel="self" type="application/rss+xml"/><item><title>Moving the embedded world to WebAssembly : Practice in CHRE</title><link>https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/</link><pubDate>Tue, 16 May 2023 15:18:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/moving-the-embedded-world-to-webassembly-practice-in-chre/</guid><description>I have recently finished my project of moving CHRE NanoApps from native to WebAssembly without changing the application source code. The source code is available in my GitHub repo cher-wasm.
The major challenges are from Wasm-Host data sharing and function callbacks. This blog will introduce the practice in integrating WASM with CHRE(Context Hub Runtime Environment), and how to some challenges. It should be useful for moving other existing project to Wasm based user applications.</description></item><item><title>The Wasm-Host sharing data: challenges</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-challenges/</link><pubDate>Mon, 24 Apr 2023 16:19:14 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-challenges/</guid><description>Background # I have tried to integrate WASM with CHRE (Context Hub Runtime Environment) at my GitHub repo (cher-wasm), and before that I learned the LVGL (Light and Versatile Graphics Library) samples provided by WAMR.
CHRE is the Android sensor hub framework where small native applications, called nanoapps, which are executed on a low-power processor and interact with the underlying system through the common CHRE API. My goal was compiling the nanoapps source code into WASM and run them on the WAMR embedded into CHRE.</description></item><item><title>The Wasm-Host sharing data: basics</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-basics/</link><pubDate>Fri, 21 Apr 2023 13:27:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wasm-host-sharing-data-basics/</guid><description>Overview # 1. Two worlds # The data transferring occur between two worlds: the native world and the Wasm world. The native world refers to the memory space that the host program can legally access, and the Wasm world refers to the memory space that the Wasm program can legally access.
The native world contains the Wasm world, so the host program can access both two worlds, but the Wasm program can access the Wasm world only.</description></item></channel></rss>