<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Li Jiongqiang on</title><link>https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/</link><description>Recent content in Li Jiongqiang on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 16 May 2023 15:18:38 +0800</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/contributors/li-jiongqiang/index.xml" rel="self" type="application/rss+xml"/><item><title>Move the embedded world to WebAssembly : practice in CHRE</title><link>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-practice-in-chre/</link><pubDate>Tue, 16 May 2023 15:18:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-practice-in-chre/</guid><description>This blog will introduce our practice in integrating WASM with CHRE(Context Hub Runtime Environment), which solves some challenges that may also be encountered in other projects.
These challenges mainly focus on data sharing and callback functions.
We will introduce the architecture used in this projects and solutions to specific challenges.
1. The overview of CHRE-WASM # CHRE is the software environment where small native applications, called nanoapp, execute on a low-power processor and interact with the underlying system through the common CHRE API.</description></item><item><title>Move the embedded world to WebAssembly : challenges</title><link>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-challenges/</link><pubDate>Mon, 24 Apr 2023 16:19:14 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-challenges/</guid><description>Background # When we try to integrate WASM with CHRE(Context Hub Rutime Environment) and LVGL(Light and Versatile Graphics Library), we meet some challenges in data transferring and sharing. The following article will introduce these challenges.
CHRE is the software environment where small native applications, called nanoapps, execute on a low-power processor and interact with the underlying system through the common CHRE API. We try to compile nanoapps into WASM and embed WAMR into CHRE to enable CHRE to run these new nanoapps compiled as WASM.</description></item><item><title>Move the embedded world to WebAssembly : basics</title><link>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-basics/</link><pubDate>Fri, 21 Apr 2023 13:27:38 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/move-the-embedded-world-to-webassembly-basics/</guid><description>Overview # 1. Two worlds # The data transferring occur between two worlds: the native world and the Wasm world. The native world refers to the memory space that the host program can legally access, and the Wasm world refers to the memory space that the Wasm program can legally access.
The native world contains the Wasm world, so the host program can access both two worlds, but the Wasm program can access the Wasm world only.</description></item></channel></rss>