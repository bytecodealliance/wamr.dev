<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Xin Wang on</title><link>https://bytecodealliance.github.io/wamr.dev/contributors/xin-wang/</link><description>Recent content in Xin Wang on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 21 Mar 2023 09:20:07 +0800</lastBuildDate><atom:link href="https://bytecodealliance.github.io/wamr.dev/contributors/xin-wang/index.xml" rel="self" type="application/rss+xml"/><item><title>The WAMR memory model</title><link>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</link><pubDate>Tue, 21 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/the-wamr-memory-model/</guid><description>The WAMR memory categories # According to the lifecycle and associated functionalities, we put the memory used in WAMR into four categories:
runtime memory: memory used by runtime globally Wasm module memory: memory used for a loaded Wasm module, freed when the module is unloaded Wasm module instance memory: memory used for a Wasm module instance, freed when the instance is destroyed Execution environment memory: memory use for execution of Wasm function from a Wasm module instance.</description></item><item><title>Understand the WAMR stacks</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</link><pubDate>Sat, 18 Mar 2023 09:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</guid><description>The status of stacks # During the WAMR executes a Wasm function, there will be a Wasm stack created and used. For interpreter mode, as the Wasm functions intercall, the Wasm stack frames will grow, while the native stack keeps unchanged.
When the Wasm calls into a imported native function and the native function then call into some Wasm function, the native stack will add a frame, and an empty frame will be inserted into wasm stack to indicate the function is imported from native.</description></item><item><title>Understand the WAMR heaps</title><link>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</link><pubDate>Fri, 17 Mar 2023 17:20:07 +0800</pubDate><guid>https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-heaps/</guid><description>Linear memory # The linear memory is a contiguous, mutable array of raw bytes. For most compilers, e.g. wasi-sdk, emsdk, rustc or asc, normally it includes three parts, data area, auxiliary stack area and heap area. The initial and maximum sizes of linear memory can be configured through the compilation parameters:
For wasi-sdk, the initial/max size can be specified with -Wl,&amp;ndash;initial-memory=n1,&amp;ndash;max-memory=n2 For emsdk, the initial/max size can be specified with -s INITIAL_MEMORY=n1 -s MAXIMUM_MEMORY=n2 -s ALLOW_MEMORY_GROWTH=1 or -s TOTAL_MEMORY=n For asc, they can be specified with &amp;ndash;initialMemory and &amp;ndash;maximumMemory flags</description></item></channel></rss>